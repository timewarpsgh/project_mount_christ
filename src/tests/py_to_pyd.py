import os
import shutil
from setuptools import setup
from Cython.Build import cythonize

def convert_py_to_pyd(py_file_path):
    """
    Converts a .py file to a .pyd file using Cython, keeping the original filename.
    Deletes temporary .c files and the original .py file after compilation.

    Args:
        py_file_path (str): Path to the .py file.

    Returns:
        str: Path to the generated .pyd file.
    """
    # Ensure the input file exists
    if not os.path.exists(py_file_path):
        raise FileNotFoundError(f"The file {py_file_path} does not exist.")

    print(f'processing {py_file_path}')

    # Get the directory and base name of the .py file
    directory, filename = os.path.split(py_file_path)
    base_name, _ = os.path.splitext(filename)

    # Create a .pyx file from the .py file
    pyx_file_path = os.path.join(directory, f"{base_name}.pyx")
    shutil.copyfile(py_file_path, pyx_file_path)

    # Create a setup.py script to compile the .pyx file
    setup_script = f"""
from setuptools import setup
from Cython.Build import cythonize

setup(
    ext_modules=cythonize("{pyx_file_path}")
)
"""
    setup_file_path = os.path.join(directory, "setup.py")
    with open(setup_file_path, "w") as f:
        f.write(setup_script)

    # Compile the .pyx file into a .pyd file
    os.chdir(directory)
    os.system(f"python {setup_file_path} build_ext --inplace")

    # Locate the generated .pyd file
    pyd_file_path = None
    for file in os.listdir(directory):
        if file.endswith(".pyd") and file.startswith(base_name):
            pyd_file_path = os.path.join(directory, file)
            break

    if not pyd_file_path:
        raise RuntimeError("Failed to generate the .pyd file.")

    # Rename the .pyd file to match the original .py file name
    final_pyd_path = os.path.join(directory, f"{base_name}.pyd")
    os.rename(pyd_file_path, final_pyd_path)

    # Clean up temporary files
    os.remove(pyx_file_path)
    os.remove(setup_file_path)
    build_dir = os.path.join(directory, "build")
    if os.path.exists(build_dir):
        shutil.rmtree(build_dir)

    # Delete the .c file generated by Cython
    c_file_path = os.path.join(directory, f"{base_name}.c")
    if os.path.exists(c_file_path):
        os.remove(c_file_path)

    # Delete the original .py file
    os.remove(py_file_path)

    return final_pyd_path


def process_py_files(directory, given_function):
    """
    Recursively finds all .py files in the given directory and applies a function to each file.

    Args:
        directory (str): The root directory to search for .py files.
        given_function (function): A function to apply to each .py file. The function should accept
                                   a single argument (the path to the .py file).

    Returns:
        None
    """
    # Ensure the directory exists
    if not os.path.exists(directory):
        raise FileNotFoundError(f"The directory {directory} does not exist.")

    # Walk through the directory recursively
    for root, _, files in os.walk(directory):
        for file in files:
            # Check if the file has a .py extension
            if file.endswith(".py") and file not in ['asset_mgr.py', 'translator.py']:
                # Construct the full path to the .py file
                py_file_path = os.path.join(root, file)
                # Apply the given function to the .py file
                given_function(py_file_path)

def print_file_path(file_path):
    print(f"Processing: {file_path}")


def main():

    # Specify the directory to search for .py files
    target_directory = r"D:\data\code\python\client_only_encripted\src"

    # Call the function to process all .py files
    process_py_files(target_directory, convert_py_to_pyd)


if __name__ == "__main__":
    main()

